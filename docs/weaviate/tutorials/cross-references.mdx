---
title: Manage relationships with cross-references
description: Learn to use cross-references in Weaviate for connected data insights.
sidebar_position: 40
image: og/docs/tutorials.jpg
---

import SkipLink from '/src/components/SkipValidationLink'
import UpdateInProgressNote from '/_includes/update-in-progress.mdx';

import CrossReferencePerformanceNote from '/_includes/cross-reference-performance-note.mdx';

<CrossReferencePerformanceNote />

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import XRefCrudPythonCode from '!!raw-loader!/_includes/code/howto/manage-data.cross-refs.py';
import XRefCrudTSCode from '!!raw-loader!/_includes/code/howto/manage-data.cross-refs';
import XRefCrudJavaCode from '!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.cross-refs.java';
import XRefCrudGoCode from '!!raw-loader!/_includes/code/howto/go/docs/manage-data.cross-refs_test.go';

import SearchBasicsPythonCode from '!!raw-loader!/_includes/code/howto/search.basics.py';
import SearchBasicsTSCode from '!!raw-loader!/_includes/code/howto/search.basics.ts';

import FilterPythonCode from '!!raw-loader!/_includes/code/howto/search.filters.py';
import FilterJavaScriptCode from '!!raw-loader!/_includes/code/howto/search.filters.ts';

In this tutorial, you will learn how to use cross-references to manage relationships between objects, and to use them to enhance your queries.

Many applications require the ability to manage relationships between objects. For example, a blog application might need to store information about the author of each post. Or, a document store may chunk documents into smaller pieces and store them in separate objects, each with a reference to the original document.

In Weaviate, you can use cross-references to manage relationships between objects. In the preceding examples, a blog post class could have a cross-reference property called `hasAuthor` to link each post to its author, or a chunk class could have a cross-reference property called `sourceDocument` to link each chunk to its original document.

We will refer to the originating object as the **source** object, and the object that is being linked to (cross-referenced object) as the **target** object.

### Prerequisites

This tutorial assumes that you have completed the [QuickStart tutorial](docs/weaviate/quickstart/index.md) and have access to a Weaviate instance with write access.

## When to use cross-references

Cross-references are useful when you need to establish relationships between objects in Weaviate. For example, you might want to link:

- A blog post (source) to its author (target).
- A document chunk (source) to its original document (target).
- A product (source) to its manufacturer (target).
- A quiz item (source) to its category (target).

In each of these cases, you can use a cross-reference property to link the objects together.

### Design Considerations for Cross-References

When deciding whether to use cross-references, consider the following trade-offs:

#### Cross-References vs Denormalization

- **Cross-References**:
  - Pros:
    - Maintain data integrity
    - Allow independent updates of related objects
    - Reduce data redundancy
  - Cons:
    - Can impact query performance
    - Require additional joins during retrieval
    - Slightly more complex to manage

- **Denormalization**:
  - Pros:
    - Faster read performance
    - Simpler query structure
    - No additional joins required
  - Cons:
    - Data redundancy
    - Potential inconsistency if not carefully managed
    - More complex to update

#### When to Choose Cross-References

Choose cross-references when:
- You need to maintain data independence
- Related objects change frequently
- You want to minimize data duplication
- Strict data consistency is crucial

Choose denormalization when:
- Read performance is critical
- Related data rarely changes
- You have a read-heavy workload
- Simplicity of querying is preferred

#### Performance Considerations

- Cross-references can introduce additional query complexity
- For high-performance scenarios, consider:
  - Limiting cross-reference depth
  - Using batch operations
  - Carefully designing your data model
- Monitor and benchmark your specific use case

> **Performance Warning**: Extensive use of cross-references, especially multiple levels deep, can significantly impact query performance. Always test and profile your specific implementation.

## How cross-references work

In Weaviate, cross-reference relationships are defined at the source class as a property. Each of these properties is characterized by a name and a data type. Each cross-reference property can be directed to one or more target classes. For example, a `hasAuthor` cross-reference property might be directed to the `Author` class, while a `sourceDocument` cross-reference property might be directed to the `Document` class.

### Advanced Cross-Reference Mechanics

#### Directionality of Cross-References

Cross-references are uni-directional; to establish a bi-directional relationship, two distinct cross-reference properties are required, facilitating linkage in both directions.

Example of bi-directional references:
```json
{
    "class": "Book",
    "properties": [{
        "name": "hasAuthor",
        "dataType": ["Author"]
    }]
},
{
    "class": "Author",
    "properties": [{
        "name": "writtenBooks",
        "dataType": ["Book"]
    }]
}
```

#### Cross-References and Vectors

Linking objects with cross-references does not affect the vectorization of the objects. This means:

- The vector representation remains independent of cross-references
- Cross-references do not influence semantic similarity
- You can create references without changing object embeddings

#### Best Practices for Cross-References

1. **Keep References Lightweight**
   - Only create cross-references when necessary
   - Avoid creating references for every possible relationship

2. **Consider Query Patterns**
   - Design cross-references based on how you'll query the data
   - Optimize for your most common access patterns

3. **Use Batch Operations**
   - When creating multiple cross-references, use batch methods
   - Reduces overhead and improves performance

4. **Monitor Performance**
   - Profile your queries with cross-references
   - Be prepared to denormalize or adjust your model if performance suffers

> **Important**: While cross-references provide powerful linking capabilities, they can introduce complexity and potential performance bottlenecks. Always test and benchmark your specific use case.

## Managing cross-references

Each cross-reference can be created, updated, and deleted independently of the objects that it links. This allows you to manage relationships between objects without having to modify the objects themselves.

To create a cross-reference, you must include the cross-reference property in the source class, and then add the cross-reference to the source object.

### Include a cross-reference property

A cross-reference property must be included in the class definition. For example, to create a `hasAuthor` cross-reference property in the `BlogPost` class, you would include the following in the class definition:

```json
{
    "class": "BlogPost",
    "properties": [
        ...  // other class properties
        // highlight-start
        {
            "name": "hasAuthor",
            "dataType": ["Author"],
        },
        // highlight-end
    ],
    ...  // other class attributes (e.g. vectorizer)
}
```

### Create a cross-reference

To create a cross-reference, Weaviate requires the following information:

- The class and UUID of the source (from) object.
- The class and UUID of the target (to) object.
- The name of the cross-reference property.

An example syntax is shown below:

<Tabs groupId="languages">
  <TabItem value="py" label="Python">

  <FilteredTextBlock
    text={XRefCrudPythonCode}
    startMarker="# START OneWay"
    endMarker="# END OneWay"
    language="py"
  />

  </TabItem>

  <TabItem value="java" label="Java">
    <FilteredTextBlock
      text={XRefCrudJavaCode}
      startMarker="// START OneWay"
      endMarker="// END OneWay"
      language="java"
    />
  </TabItem>

  <TabItem value="go" label="Go">
    <FilteredTextBlock
      text={XRefCrudGoCode}
      startMarker="// START OneWay"
      endMarker="// END OneWay"
      language="go"
    />
  </TabItem>
</Tabs>

## Queries with cross-references

Once you have established cross-references between objects, you can use them to enhance your search queries. For example, you can use cross-references to:

- Retrieve properties of target objects.
- Filter objects based on properties of target objects.

### Retrieve properties of a target object

You can retrieve properties of a target object just as you would retrieve properties of the source object.

For example, where a document chunk includes a cross-reference to its original document, you can use the cross-reference to retrieve properties of the original document. Accordingly, you can retrieve the title of the document or the author of the document, just as you would retrieve a property of the chunk itself such as the text of the chunk.

Take a look at the snippet below in which we retrieve objects from the `JeopardyQuestion` class. Here, the `JeopardyQuestion` class contains the `hasCategory` cross-reference property, linking objects to the `JeopardyCategory` class. This query retrieves the `title` property of the target `JeopardyCategory` class, as well as the `question` property of the source `JeopardyQuestion` class.

<Tabs groupId="languages">
<TabItem value="py" label="Python">

<FilteredTextBlock
  text={SearchBasicsPythonCode}
  startMarker="# GetWithCrossRefsPython"
  endMarker="# END GetWithCrossRefsPython"
  language="py"
/>

</TabItem>
<TabItem value="graphql" label="GraphQL">

<FilteredTextBlock
  text={SearchBasicsPythonCode}
  startMarker="# GetWithCrossRefsGraphQL"
  endMarker="# END GetWithCrossRefsGraphQL"
  language="graphql"
/>

</TabItem>
</Tabs>

### Filter using cross-references

You can configure a filter to include or exclude objects based on properties of the target object.

For example, you can filter articles based on an attribute of the author, such as the author's name or the author's location.

Take a look at the snippet below, This query looks through the `JeopardyQuestion` class, but the results are filtered using the `title` property of its cross-referenced `JeopardyCategory` class. The `title` property must include the substring `Sport`.

<Tabs groupId="languages">
<TabItem value="py" label="Python">
<FilteredTextBlock
  text={FilterPythonCode}
  startMarker="# CrossReferencePython"
  endMarker="# END CrossReferencePython"
  language="python"
/>
</TabItem>
<TabItem value="graphql" label="GraphQL">
<FilteredTextBlock
  text={FilterPythonCode}
  startMarker="# CrossReferenceGraphQL"
  endMarker="# END CrossReferenceGraphQL"
  language="graphql"
/>
</TabItem>
</Tabs>

:::tip Two-stage queries

Because cross-references do not affect vectors, you cannot use vector searches to filter objects based on properties of the target object.

However, you could use two separate queries to achieve a similar result. For example, you could perform a vector search to identify `JeopardyCategory` objects that are similar to a given vector, resulting in a list of `JeopardyCategory` objects. You could then use the unique `title` properties of these objects in a second query filter the results as shown above. This will result in `JeopardyQuestion` objects that are cross-referenced to the `JeopardyCategory` objects identified in the first query.

## Cross-reference Design Patterns

Cross-references can model various relationship types with different characteristics:

### One-to-One Relationships

```json
{
    "class": "User",
    "properties": [{
        "name": "profile",
        "dataType": ["UserProfile"]
    }]
}
```

- Best for: Unique, exclusive relationships
- Pros: Clear, direct linkage
- Cons: Can be less flexible than embedded data

### One-to-Many Relationships

```json
{
    "class": "Author",
    "properties": [{
        "name": "books",
        "dataType": ["Book"]
    }]
}
```

- Best for: When one object can have multiple related objects
- Pros:
  - Flexible
  - Allows independent management of related objects
- Cons:
  - Potential performance overhead
  - Complex querying

### Many-to-Many Relationships

```json
{
    "class": "Student",
    "properties": [{
        "name": "courses",
        "dataType": ["Course"]
    }]
},
{
    "class": "Course",
    "properties": [{
        "name": "students",
        "dataType": ["Student"]
    }]
}
```

- Best for: Complex relationships with multiple interconnections
- Pros:
  - Maximum flexibility
  - True representation of complex relationships
- Cons:
  - Most complex to query
  - Higher performance overhead

### Choosing the Right Pattern

- **One-to-One**: When objects have a unique, exclusive relationship
- **One-to-Many**: When one object can have multiple related objects
- **Many-to-Many**: When objects have complex, bidirectional relationships

Always consider your specific use case, performance requirements, and query patterns when designing cross-references.

## Further information

### Managing cross-references

For further information on how to manage cross-references, see the [how-to guide on cross-references](../manage-collections/cross-references.mdx). It includes information on how to:

- [Create a cross-reference](../manage-collections/cross-references.mdx#add-a-one-way-cross-reference)
- [Update a cross-reference](../manage-collections/cross-references.mdx#update-a-cross-reference)
- [Delete a cross-reference](../manage-collections/cross-references.mdx#delete-a-cross-reference)
- [Retrieve a cross-reference](../manage-collections/cross-references.mdx#read-cross-references)

:::info Related pages
- [How-to search: Filters](../search/filters.md)
- <SkipLink href="/weaviate/api/rest#tag/objects">API References: Objects</SkipLink>
:::